#include  <Arduino.h>
class game0
{
  int i,f,g,h;
  public:
  int Combo=0;
  byte contral=0;//哪隻搖桿控制
  int location[2]={0,4};//y,x方塊位置     
  int direction=0;//方塊朝向
  int state[4]={0,0,0,0};//方塊移動時回傳狀態[0]:上下是否有觸碰 [1]:左右是否有觸碰 [2]:是否觸碰固定方塊 [3]:此格是否在螢幕內
  bool drop=0;//方塊是否正在落下
  int drop_time=800;//落下需要的時間
  int drop_time_r=800;
  int block_choose=0;//選擇要落下的方塊
  bool MAP[3][20][10];//0:固定的方塊 1:方塊落下判斷用 2:原本在落下的方塊
  int MAP_color[20][10];//rgb
  const int color[7]={256*256*48+256*48,256*256*96,256*36+60,256*96,256*48+48,256*256*48+48,96};//儲存顏色
  bool wall[20][1]=
  {
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1},
    {1}
  };
  bool block[6][4][3][3]=//方塊圖形 [種類][方向][y][x]
  {{{ {1,0,0},
      {1,1,1},
      {0,0,0}
    },
    {
      {0,1,1},
      {0,1,0},
      {0,1,0}
    },
    {
      {0,0,0},
      {1,1,1},
      {0,0,1}
    },
    {
      {0,1,0},
      {0,1,0},
      {1,1,0}
    }
    },
    {
    {
      {0,0,1},
      {1,1,1},
      {0,0,0}
    },
    {
      {0,1,0},
      {0,1,0},
      {0,1,1}
    },
    {
      {0,0,0},
      {1,1,1},
      {1,0,0}
    },
    {
      {1,1,0},
      {0,1,0},
      {0,1,0}
    }
    },
    {
    {
      {0,1,1},
      {1,1,0},
      {0,0,0}
    },
    {
      {0,1,0},
      {0,1,1},
      {0,0,1}
    },
    {
      {0,0,0},
      {0,1,1},
      {1,1,0}
    },
    {
      {1,0,0},
      {1,1,0},
      {0,1,0}
    }
    },
    {
    {
      {1,1,0},
      {1,1,0},
      {0,0,0}
    },
    {
      {1,1,0},
      {1,1,0},
      {0,0,0}
    },
    {
      {1,1,0},
      {1,1,0},
      {0,0,0}
    },
    {
      {1,1,0},
      {1,1,0},
      {0,0,0}
    }
    },
    {
    {
      {0,1,0},
      {1,1,1},
      {0,0,0}
    },
    {
      {0,1,0},
      {0,1,1},
      {0,1,0}
    },
    {
      {0,0,0},
      {1,1,1},
      {0,1,0}
    },
    {
      {0,1,0},
      {1,1,0},
      {0,1,0}
    }
    },
    {
    {
      {1,1,0},
      {0,1,1},
      {0,0,0}
    },
    {
      {0,0,1},
      {0,1,1},
      {0,1,0}
    },
    {
      {0,0,0},
      {1,1,0},
      {0,1,1}
    },
    {
      {0,1,0},
      {1,1,0},
      {1,0,0}
  }}};
  int block_l[2][4][4]=	//l型方塊
  {{	{0,0,0,0},
      {1,1,1,1},
      {0,0,0,0},
      {0,0,0,0}
    },
    {
      {0,1,0,0},
      {0,1,0,0},
      {0,1,0,0},
      {0,1,0,0}
  }};

  void initialize(void)//方塊開始落下初始化
  {
    drop=1;//開始下降
    block_choose=random(0,7);//隨機選擇掉落方塊0~6
    direction=0;//方向回復
    location[0]=0;//位置回復
    location[1]=4;//位置回復
  }
  void move(void)//方塊移動
  {
    state[0]=0;
    state[1]=0;
    state[2]=0;
    for(i=0;i<20;i++)//模擬移動陣列歸零
    {
      for(f=0;f<10;f++)
      {
        MAP[1][i][f]=0;
      }
    }
    if(block_choose==0)
    {
      for(i=0;i<4;i++)//創建模擬移動陣列(l型方塊)
      {
        for(f=0;f<4;f++)
        {          
          state[3]=0;
          if(block_l[direction%2][i][f]==1)
          {
            if((location[0]+i-1)>19)//落下是否超出下方邊界
            {
              state[0]=1;
              state[3]=1;
            }
            else if((location[0]+i-1)<0)//落下是否超出上方邊界
            {
              state[0]=2;
              state[3]=1;
            }
            if((location[1]+f-1)>9)//是否超出右邊邊界
            {
              state[1]=1;
              state[3]=1;
            }
            else if((location[1]+f-1)<0)//是否超出左邊邊界
            {
              state[1]=2;
              state[3]=1;
            }
            if((state[3]==0)&&(MAP[0][location[0]+i-1][location[1]+f-1]==1))//是否觸碰到其他方塊
            {
              state[2]=1;
              state[3]=1;
            }
            if(state[3]==0)//可以移動
            {
              MAP[1][location[0]+i-1][location[1]+f-1]=1;
            }
          }
        }
      }
    }
    else
    {
      for(i=0;i<3;i++)//創建模擬移動陣列(其他方塊)
      {
        for(f=0;f<3;f++)
        {    
          state[3]=0;    
          if(block[block_choose-1][direction][i][f]==1)
          {
            if((location[0]+i-1)>19)//落下是否超出下方邊界
            {
              state[0]=1;
              state[3]=1;
            }
            else if((location[0]+i-1)<0)//落下是否超出上方邊界
            {
              state[0]=2;
              state[3]=1;
            }
            if((location[1]+f-1)>9)//是否超出右邊邊界
            {
              state[1]=1;
              state[3]=1;
            }
            else if((location[1]+f-1)<0)//是否超出左邊邊界
            {
              state[1]=2;
              state[3]=1;
            }
            if((state[3]==0)&&(MAP[0][location[0]+i-1][location[1]+f-1]==1))//是否觸碰到其他方塊
            {
              state[2]=1;
              state[3]=1;
            }
            if(state[3]==0)//可以移動
            {
              MAP[1][location[0]+i-1][location[1]+f-1]=1;
            }
          }
        }
      }
    } 
  }
  void freeze(void)//移動方塊固定
  {
    for(i=0;i<20;i++)
    {
      for(f=0;f<10;f++)
      {
        if(MAP[2][i][f]==1)
        {
          MAP[0][i][f]=1;
          MAP_color[i][f]=color[block_choose];
        }
      }
    }
  }
  void log(void)//紀錄落下方塊
  {
    for(i=0;i<20;i++)
    {
      for(f=0;f<10;f++)
      {
        MAP[2][i][f]=MAP[1][i][f];
      }
    }
  }
  int erase(void)//消除行
  {
    int row=0;//減少選擇消除列數
    int row_conut=0;//列格數
    for(i=19;i>(-1);i--)
    {
      row_conut=0;
      for(f=0;f<10;f++)
      {
        if(MAP[0][i][f])
        {
          row_conut++;
        }
      }
      if(row_conut==10)
      {
        for(f=0;f<10;f++)
        {
          MAP[0][i][f]=0;
          MAP_color[i][f]=0;
        }
        row++;
      }
      else if(row!=0)
      {
        for(f=0;f<10;f++)
        {
          MAP[0][i+row][f]=MAP[0][i][f];
          MAP[0][i][f]=0;
          MAP_color[i+row][f]=MAP_color[i][f];
          MAP_color[i][f]=0;
        }   
      }
    }
    return row;
  }
  void end(void)
  {
    drop=0;
    drop_time=800;
    drop_time_r=800;
    for(i=0;i<20;i++)
    {
      for(f=0;f<10;f++)
      {
        MAP[0][i][f]=0;
        MAP[1][i][f]=0;
        MAP[2][i][f]=0;
        MAP_color[i][f]=0;
      }
    }
  }
};