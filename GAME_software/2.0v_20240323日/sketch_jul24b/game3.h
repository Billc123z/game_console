#include  <Arduino.h>
class game3
{
  public:
    byte contral=0;//哪隻搖桿控制
    bool number[16][5][5]=
    {{{0,0,0,0,0},//1圖片
     {0,0,0,0,0},
     {0,0,1,0,0},
     {0,0,0,0,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//2圖片
     {0,1,0,0,0},
     {0,0,0,0,0},
     {0,0,0,1,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//3圖片
     {0,0,0,1,0},
     {0,0,1,0,0},
     {0,1,0,0,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//4圖片
     {0,1,0,1,0},
     {0,0,0,0,0},
     {0,1,0,1,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//5圖片
     {0,1,0,1,0},
     {0,0,1,0,0},
     {0,1,0,1,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//6圖片
     {0,1,0,1,0},
     {0,1,0,1,0},
     {0,1,0,1,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//7圖片
     {0,1,0,1,0},
     {0,1,1,1,0},
     {0,1,0,1,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//8圖片
     {0,1,1,1,0},
     {0,1,0,1,0},
     {0,1,1,1,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//9圖片
     {0,1,1,1,0},
     {0,1,1,1,0},
     {0,1,1,1,0},
     {0,0,0,0,0}
    },
    {{0,0,1,0,0},//10圖片
     {0,1,1,1,0},
     {0,1,0,1,0},
     {0,1,1,1,0},
     {0,0,1,0,0}
    },
    {{0,1,0,1,0},//11圖片
     {0,1,0,1,0},
     {0,1,1,1,0},
     {0,1,0,1,0},
     {0,1,0,1,0}
    },
    {{0,1,0,1,0},//12圖片
     {0,1,1,1,0},
     {0,1,0,1,0},
     {0,1,1,1,0},
     {0,1,0,1,0}
    },
    {{0,1,0,1,0},//13圖片
     {0,1,1,1,0},
     {0,1,1,1,0},
     {0,1,1,1,0},
     {0,1,0,1,0}
    },
    {{0,1,1,1,0},//14圖片
     {0,1,1,1,0},
     {0,1,0,1,0},
     {0,1,1,1,0},
     {0,1,1,1,0}
    },
    {{0,0,0,0,0},//15圖片
     {0,0,1,0,0},
     {0,1,0,1,0},
     {0,0,1,0,0},
     {0,0,0,0,0}
    },
    {{0,0,0,0,0},//16圖片
     {0,0,1,0,0},
     {0,1,1,1,0},
     {0,0,1,0,0},
     {0,0,0,0,0}
    }};
    int back_color[3][7]=
    {{0,0,60,0,48,48,96},
     {48,0,36,96,48,0,0},
     {48,96,0,0,0,48,0}
    };
    int fraction_add=0;
    int amount=0;//有幾個格子有數字
    int number_log[4][4]={0};//紀錄位置數字
    int number_log_last[4][4]={0};//上次紀錄位置數字(動畫用)
    int number_move[4][4]={0};//記錄此格數字移動了幾格(動畫用)
    int number_color[20][20]={0};//畫面顏色(動畫用)
    bool add[4][4]={0};//[y][x]是否要加起來
    bool move_state=0;//本次方格紀錄是否移動過
    bool move_state_all=0;//方格紀錄是否移動過
    int direction;//(動畫用)
    void initialize(void)//初始化
    {
      int i,f;
      amount=0;
      move_state_all=0;
      for(i=0;i<16;i++)
      {
        number_log[i%4][i/4]=0;
        number_log_last[i%4][i/4]=0;
        number_move[i][f]=0;
      }
    }
    void move(byte diraction/*0:上1:下2:左3:右*/)//方塊移動
    {
      int i,f,g;
      ////狀態歸零
      move_state=0;
      for(i=0;i<4;i++)
      {
        for(f=0;f<4;f++)
        {
          number_move[i][f]=0;
        }
      }
      switch(diraction)
      {
        case 0:
          for(i=1;i<4;i++)//第一排不需要掃描
          {
            for(f=0;f<4;f++)
            {
              if(number_log[i][f]!=0)//有數字
              {
                if(number_log[i-1][f]!=0)//下一格有數字
                {
                  if(number_log[i-1][f]==number_log[i][f]&&add[i-1][f]==0&&add[i][f]==0)//一樣的數字可以增加並且自己沒被加過或是下一個數字也沒被加過
                  {
                    fraction_add+=number_log[i][f]+1;
                    amount--;
                    move_state=1;
                    number_log[i-1][f]++;
                    number_log[i][f]=0;
                    number_move[i][f]=1;
                    add[i-1][f]=1;
                  }
                  else//不一樣的數字
                  {
                  }
                }
                else//下一格沒有數字
                {
                  number_log[i-1][f]=number_log[i][f];
                  number_log[i][f]=0;
                  move_state=1;
                  number_move[i][f]=1;
                }
              }
            }
          }
          break;
        case 1:
          for(i=2;i>-1;i--)//第一排不需要掃描
          {
            for(f=0;f<4;f++)
            {
              if(number_log[i][f]!=0)//有數字
              {
                if(number_log[i+1][f]!=0)//下一格有數字
                {
                  if(number_log[i+1][f]==number_log[i][f]&&add[i+1][f]==0&&add[i][f]==0)//一樣的數字可以增加
                  {
                    fraction_add+=number_log[i][f]+1;
                    amount--;
                    move_state=1;
                    number_log[i+1][f]++;
                    number_log[i][f]=0;
                    number_move[i][f]=1;
                    add[i+1][f]=1;
                  }
                  else//不一樣的數字
                  {
                  }
                }
                else//下一格沒有數字
                {
                  number_log[i+1][f]=number_log[i][f];
                  number_log[i][f]=0;
                  move_state=1;
                  number_move[i][f]=1;
                }
              }
            }
          }
          break; 
        case 2:
          for(f=1;f<4;f++)//第一排不需要掃描
          {
            for(i=0;i<4;i++)
            {
              if(number_log[i][f]!=0)//有數字
              {
                if(number_log[i][f-1]!=0)//下一格有數字
                {
                  if(number_log[i][f-1]==number_log[i][f]&&add[i][f-1]==0&&add[i][f]==0)//一樣的數字可以增加
                  {
                    fraction_add+=number_log[i][f]+1;
                    amount--;
                    move_state=1;
                    number_log[i][f-1]++;
                    number_log[i][f]=0;
                    number_move[i][f]=1;
                    add[i][f-1]=1;
                  }
                  else//不一樣的數字
                  {
                  }
                }
                else//下一格沒有數字
                {
                  number_log[i][f-1]=number_log[i][f];
                  number_log[i][f]=0;
                  move_state=1;
                  number_move[i][f]=1;
                }
              }
            }
          }
          break;
        case 3:
          for(f=2;f>-1;f--)//第一排不需要掃描
          {
            for(i=0;i<4;i++)
            {
              if(number_log[i][f]!=0)//有數字
              {
                if(number_log[i][f+1]!=0)//下一格有數字
                {
                  if(number_log[i][f+1]==number_log[i][f]&&add[i][f+1]==0&&add[i][f]==0)//一樣的數字可以增加
                  {
                    fraction_add+=number_log[i][f]+1;
                    amount--;
                    move_state=1;
                    number_log[i][f+1]++;
                    number_log[i][f]=0;
                    number_move[i][f]=1;
                    add[i][f+1]=1;
                  }
                  else//不一樣的數字
                  {
                  }
                }
                else//下一格沒有數字
                {
                  number_log[i][f+1]=number_log[i][f];
                  number_log[i][f]=0;
                  move_state=1;
                  number_move[i][f]=1;
                }
              }
            }  
          }
          break;
      }
    }
    void New(void)//產生新數字
    {
      int i,f;
      fraction_add=0;
      amount++;
      for(i=0;i<4;i++)
      {
        for(f=0;f<4;f++)
        {
          add[i][f]=0;
        }
      }
      do
      {
        i=random(0,4);//隨機選擇y位置(0~3)
        f=random(0,4);//隨機選擇x位置(0~3)
      }while(number_log[i][f]!=0);
      number_log[i][f]=random(1,3);//隨機新增數字(1、2)
      for(i=0;i<4;i++)//記錄新的位置到上次紀錄中
      {
        for(f=0;f<4;f++)
        {
          number_log_last[i][f]=number_log[i][f];
        }
      }
    }
    void move_anime(int direction,int number_move_already)//移動動畫
    {
      int i,f,g,h;
      for(i=0;i<20;i++)//初始化
      {
        for(f=0;f<20;f++)
        {
          number_color[i][f]=0;
        }
      }
      for(i=0;i<4;i++)//
      {
        for(f=0;f<4;f++)
        {
          if(number_move_already!=5)//未到動畫最後一步
          {
            if(number_move[i][f]==1)//數字要移動
            {
              for(g=0;g<5;g++)
              {
                for(h=0;h<5;h++)
                {
                  if(number[number_log_last[i][f]-1][g][h]==1)//貼上數字
                  {
                    switch(direction)
                    {
                      case 0:
                        number_color[i*5-number_move_already+g][f*5+h]=255+256*255+256*256*255;
                        break;
                      case 1:
                        number_color[i*5+number_move_already+g][f*5+h]=255+256*255+256*256*255;
                        break;
                      case 2:
                        number_color[i*5+g][f*5-number_move_already+h]=255+256*255+256*256*255;
                        break;
                      case 3:
                        number_color[i*5+g][f*5+number_move_already+h]=255+256*255+256*256*255;
                        break;
                    }
                  }
                  else//放上底色
                  {
                    switch(direction)
                    {
                      case 0:
                          number_color[i*5-number_move_already+g][f*5+h]=back_color[0][number_log_last[i][f]%7]+256*back_color[1][number_log_last[i][f]%7]+256*256*back_color[2][number_log_last[i][f]%7];
                        break;
                      case 1:
                          number_color[i*5+number_move_already+g][f*5+h]=back_color[0][number_log_last[i][f]%7]+256*back_color[1][number_log_last[i][f]%7]+256*256*back_color[2][number_log_last[i][f]%7];
                        break;
                      case 2:
                          number_color[i*5+g][f*5-number_move_already+h]=back_color[0][number_log_last[i][f]%7]+256*back_color[1][number_log_last[i][f]%7]+256*256*back_color[2][number_log_last[i][f]%7];
                        break;
                      case 3:
                          number_color[i*5+g][f*5+number_move_already+h]=back_color[0][number_log_last[i][f]%7]+256*back_color[1][number_log_last[i][f]%7]+256*256*back_color[2][number_log_last[i][f]%7];
                        break;      
                    }
                  }
                }
              } 
            }
            else if(number_move[i][f]==0&&number_log_last[i][f]!=0)//有數字且數字沒有移動
            {
              for(g=0;g<5;g++)
              {
                for(h=0;h<5;h++)
                {              
                  if(number[number_log_last[i][f]-1][g][h]==1)//貼上數字
                  {
                    number_color[i*5+g][f*5+h]=255+256*255+256*256*255;
                  }
                  else//放上底色
                  {
                      number_color[i*5+g][f*5+h]=back_color[0][number_log_last[i][f]%7]+256*back_color[1][number_log_last[i][f]%7]+256*256*back_color[2][number_log_last[i][f]%7];
                  } 
                }
              }
            }
          }
          else if(number_move_already==5)//動畫最後一步
          {
            if(number_log[i][f]!=0)//移動完有數字
            {
              for(g=0;g<5;g++)
              {
                for(h=0;h<5;h++)
                {              
                  if(number[number_log[i][f]-1][g][h]==1)//貼上數字
                  {
                    number_color[i*5+g][f*5+h]=255+256*255+256*256*255;
                  }
                  else//放上底色
                  {
                      number_color[i*5+g][f*5+h]=back_color[0][number_log[i][f]%7]+256*back_color[1][number_log[i][f]%7]+256*256*back_color[2][number_log[i][f]%7];
                  } 
                }
              }    
            }
            for(g=0;g<4;g++)//紀錄上次數字位置
            {
              for(h=0;h<4;h++)
              {
                number_log_last[g][h]=number_log[g][h];
              }
            }
          }
        }
      }
    }
    bool juge()//判斷是否結束
    {
      int i,f;
      bool end=1;//是否結束
      for(i=0;i<4;i++)
      {
        for(f=0;f<4;f++)
        {
          if(i+1<4&&number_log[i][f]==number_log[i+1][f]&&number_log[i+1][f]!=0)
          {
            end=0;
          }
          if(i-1>-1&&number_log[i][f]==number_log[i-1][f]&&number_log[i-1][f]!=0)
          {
            end=0;
          }
          if(f+1<4&&number_log[i][f]==number_log[i][f+1]&&number_log[i][f+1]!=0)
          {
            end=0;
          }
          if(f-1>-1&&number_log[i][f]==number_log[i][f-1]&&number_log[i][f-1]!=0)
          {
            end=0;
          }
        }
      }
      return end;
    }
    
};